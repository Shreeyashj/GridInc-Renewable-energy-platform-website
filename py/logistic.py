import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, accuracy_score, confusion_matrix, classification_report

# Function to load data for RandomForestRegressor
def load_data_rf():
    train_test_data = pd.read_csv('train_test_data.csv', parse_dates=['DateTime'], index_col='DateTime')
    validation_data = pd.read_csv('validation_data.csv', parse_dates=['DateTime'], index_col='DateTime')
    return train_test_data, validation_data

# Function for feature engineering for RandomForestRegressor
def add_time_features_rf(df):
    df['hour'] = df.index.hour
    df['dayofweek'] = df.index.dayofweek
    df['month'] = df.index.month
    return df

# Function to train the RandomForestRegressor model
def train_model_rf(train_test_data):
    train_test_data = add_time_features_rf(train_test_data)
    features = ['Air temperature | (Â°C)', 'Pressure | (atm)', 'Wind speed | (m/s)', 'hour', 'dayofweek', 'month']
    target = 'Power generated by system | (MW)'
    X = train_test_data[features]
    y = train_test_data[target]
    X_train, _, y_train, _ = train_test_split(X, y, test_size=0.3, random_state=42)
    rf_model = RandomForestRegressor(n_estimators=50, random_state=42)
    rf_model.fit(X_train, y_train)
    return rf_model, features, target

# Function to predict power generation and calculate accuracy for RandomForestRegressor
def predict_and_evaluate_rf(rf_model, features, validation_data, date_time):
    if date_time in validation_data.index:
        data_point = validation_data.loc[date_time, features].values.reshape(1, -1)
        predicted_power = rf_model.predict(data_point)[0]
        actual_power = validation_data.loc[date_time, 'Power generated by system | (MW)']
        if np.isnan(predicted_power) or np.isnan(actual_power):
            return None, None, None
        error = np.abs(predicted_power - actual_power)
        mape = (error / actual_power) * 100
        accuracy = 100 - mape
        return predicted_power, actual_power, accuracy
    else:
        return None, None, None

# Function to create visualizations for RandomForestRegressor
def create_visualizations_rf(validation_data, date_time_input, predicted_power, actual_power, rf_model, features):
    visualizations = []

    # Line plot
    fig1, ax1 = plt.subplots(figsize=(7, 4))
    time_range = pd.date_range(start=date_time_input - pd.Timedelta(days=3), end=date_time_input + pd.Timedelta(days=3), freq='h')
    time_range = time_range[time_range.isin(validation_data.index)]
    range_data = validation_data.loc[time_range]
    range_data['Predicted'] = rf_model.predict(range_data[features])
    sns.lineplot(data=range_data[['Power generated by system | (MW)', 'Predicted']], ax=ax1)
    ax1.set_title('Actual vs. Predicted Power (3-day Range)')
    ax1.set_xlabel('DateTime')
    ax1.set_ylabel('Power (MW)')
    visualizations.append(fig1)

    # Bar plot
    fig2, ax2 = plt.subplots(figsize=(7, 4))
    colors = ['blue' if x == 'Actual' else 'orange' for x in ['Actual', 'Predicted']]
    ax2.bar(['Actual', 'Predicted'], [actual_power, predicted_power], color=colors)
    ax2.set_title('Actual vs. Predicted Power')
    ax2.set_ylabel('Power (MW)')
    visualizations.append(fig2)

    # Scatter plot
    fig3, ax3 = plt.subplots(figsize=(7, 4))
    scatter_data = validation_data.copy()
    scatter_data['Predicted'] = rf_model.predict(scatter_data[features])
    sns.scatterplot(x='Power generated by system | (MW)', y='Predicted', data=scatter_data, ax=ax3)
    ax3.plot([scatter_data['Power generated by system | (MW)'].min(), scatter_data['Power generated by system | (MW)'].max()], 
             [scatter_data['Power generated by system | (MW)'].min(), scatter_data['Power generated by system | (MW)'].max()], 
             'r--')
    ax3.set_title('Actual vs. Predicted Power (Scatter Plot)')
    ax3.set_xlabel('Actual Power (MW)')
    ax3.set_ylabel('Predicted Power (MW)')
    visualizations.append(fig3)

    # Distribution ratios
    distribution_ratios = [0.20, 0.45, 0.35]

    def make_autopct(values):
        def my_autopct(pct):
            total = sum(values)
            if not np.isnan(total) and total != 0:  # Check if total is not NaN and not zero
                val = int(round(pct*total/100.0))
            else:
                val = 0
            return '{p:.2f}%\n({v:d} MW)'.format(p=pct, v=val)
        return my_autopct

    # Pie chart for Predicted Power Distribution
    predicted_distribution = [predicted_power * ratio for ratio in distribution_ratios]
    fig4, ax4 = plt.subplots()
    ax4.pie(predicted_distribution, labels=['Node 1', 'Node 2', 'Node 3'], autopct=make_autopct(predicted_distribution))
    ax4.set_title('Predicted Power Distribution among Nodes')
    visualizations.append(fig4)

    # Pie chart for Actual Power Distribution
    actual_distribution = [actual_power * ratio for ratio in distribution_ratios]
    fig5, ax5 = plt.subplots()
    ax5.pie(actual_distribution, labels=['Node 1', 'Node 2', 'Node 3'], autopct=make_autopct(actual_distribution))
    ax5.set_title('Actual Power Distribution among Nodes')
    visualizations.append(fig5)

    return visualizations

# Function to load data for LogisticRegression
def load_data_lr():
    data = pd.read_csv('train_test_data.csv')  # Replace 'your_data.csv' with your actual data file path
    return data

# Function for preprocessing for LogisticRegression
def preprocess_data_lr(data):
    # Perform preprocessing if needed
    processed_data = data.copy()  # Example: No preprocessing in this case
    return processed_data

# Function to train the LogisticRegression model
def train_model_lr(data):
    X = data.drop(columns=['target_column'])  # Replace 'target_column' with your target column name
    y = data['target_column']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
    model = LogisticRegression()
    model.fit(X_train, y_train)
    return model, X_test, y_test

# Function to evaluate the LogisticRegression model
def evaluate_model_lr(model, X_test, y_test):
    y_pred = model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    confusion_mat = confusion_matrix(y_test, y_pred)
    classification_rep = classification_report(y_test, y_pred)
    return accuracy, confusion_mat, classification_rep

# Streamlit UI
st.title("Model Evaluation")
model_choice = st.selectbox("Choose Model", ["Random Forest Regressor", "Logistic Regression"])
date = st.date_input("Choose Date")
time = st.time_input("Choose Time")
date_time_input = pd.to_datetime(f"{date} {time}")  # Convert date and time to datetime object

if model_choice == "Random Forest Regressor":
    st.subheader("Random Forest Regressor")
    train_test_data_rf, validation_data_rf = load_data_rf()
    train_test_data_rf = add_time_features_rf(train_test_data_rf)
    validation_data_rf = add_time_features_rf(validation_data_rf)
    rf_model, rf_features, rf_target = train_model_rf(train_test_data_rf)

    if st.button("Predict RF"):
        predicted_power_rf, actual_power_rf, accuracy_rf = predict_and_evaluate_rf(rf_model, rf_features, validation_data_rf, date_time_input)
        if predicted_power_rf is not None and actual_power_rf is not None:
            st.write(f"Predicted Power (RF): {predicted_power_rf} MW")
            st.write(f"Actual Power (RF): {actual_power_rf} MW")
            st.write(f"Accuracy of Prediction (RF): {accuracy_rf:.2f}%")

            visualizations_rf = create_visualizations_rf(validation_data_rf, date_time_input, predicted_power_rf, actual_power_rf, rf_model, rf_features)
            for vis_rf in visualizations_rf:
                st.pyplot(vis_rf)
        else:
            st.write("Data not available for the selected date and time, or an error occurred in prediction (RF).")

elif model_choice == "Logistic Regression":
    st.subheader("Logistic Regression")
    data_lr = load_data_lr()
    processed_data_lr = preprocess_data_lr(data_lr)
    model_lr, X_test_lr, y_test_lr = train_model_lr(processed_data_lr)

    if st.button("Evaluate LR"):
        accuracy_lr, confusion_mat_lr, classification_rep_lr = evaluate_model_lr(model_lr, X_test_lr, y_test_lr)
        
        st.write(f"Accuracy (LR): {accuracy_lr:.2f}")
        st.write("Confusion Matrix (LR):")
        st.write(confusion_mat_lr)
        st.write("Classification Report (LR):")
        st.write(classification_rep_lr)
