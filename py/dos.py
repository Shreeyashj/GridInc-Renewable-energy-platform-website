import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error



# Function to load data
def load_data():
    train_test_data = pd.read_csv('train_test_data.csv', parse_dates=['DateTime'], index_col='DateTime')
    validation_data = pd.read_csv('validation data.csv', parse_dates=['DateTime'], index_col='DateTime')
    return train_test_data, validation_data

# Function for feature engineering
def add_time_features(df):
    df['hour'] = df.index.hour
    df['dayofweek'] = df.index.dayofweek
    df['month'] = df.index.month
    return df

# Function to train the model
def train_model(train_test_data):
    train_test_data = add_time_features(train_test_data)
    features = ['Air temperature | (Â°C)', 'Pressure | (atm)', 'Wind speed | (m/s)', 'hour', 'dayofweek', 'month']
    target = 'Power generated by system | (MW)'
    X = train_test_data[features]
    y = train_test_data[target]
    X_train, _, y_train, _ = train_test_split(X, y, test_size=0.3, random_state=42)
    rf_model = RandomForestRegressor(n_estimators=50, random_state=42)
   
    rf_model.fit(X_train, y_train)
    return rf_model, features, target

# Function to predict power generation and calculate accuracy
def predict_and_evaluate(rf_model, features, validation_data, date_time):
    if date_time in validation_data.index:
        data_point = validation_data.loc[date_time, features].values.reshape(1, -1)
        predicted_power = rf_model.predict(data_point)[0]
        actual_power = validation_data.loc[date_time, 'Power generated by system | (MW)']
        if np.isnan(predicted_power) or np.isnan(actual_power):
            return None, None, None
        error = np.abs(predicted_power - actual_power)
        mape = (error / actual_power) * 100
        accuracy = 100 - mape
        return predicted_power, actual_power, accuracy
    else:
        return None, None, None

# Function to create visualizations
def create_visualizations(validation_data, date_time_input, predicted_power, actual_power, rf_model, features):
    visualizations = []

    # Line plot
    fig1, ax1 = plt.subplots(figsize=(7, 4))
    time_range = pd.date_range(start=date_time_input - pd.Timedelta(days=3), end=date_time_input + pd.Timedelta(days=3), freq='h')
    time_range = time_range[time_range.isin(validation_data.index)]
    range_data = validation_data.loc[time_range]
    range_data['Predicted'] = rf_model.predict(range_data[features])
    sns.lineplot(data=range_data[['Power generated by system | (MW)', 'Predicted']], ax=ax1)
    ax1.set_title('Actual vs. Predicted Power (3-day Range)')
    ax1.set_xlabel('DateTime')
    ax1.set_ylabel('Power (MW)')
    visualizations.append(fig1)

    # Bar plot
    fig2, ax2 = plt.subplots(figsize=(7, 4))
    colors = ['blue' if x == 'Actual' else 'orange' for x in ['Actual', 'Predicted']]
    ax2.bar(['Actual', 'Predicted'], [actual_power, predicted_power], color=colors)
    ax2.set_title('Actual vs. Predicted Power')
    ax2.set_ylabel('Power (MW)')
    visualizations.append(fig2)

    # Scatter plot
    fig3, ax3 = plt.subplots(figsize=(7, 4))
    scatter_data = validation_data.copy()
    scatter_data['Predicted'] = rf_model.predict(scatter_data[features])
    sns.scatterplot(x='Power generated by system | (MW)', y='Predicted', data=scatter_data, ax=ax3)
    ax3.plot([scatter_data['Power generated by system | (MW)'].min(), scatter_data['Power generated by system | (MW)'].max()], 
             [scatter_data['Power generated by system | (MW)'].min(), scatter_data['Power generated by system | (MW)'].max()], 
             'r--')
    ax3.set_title('Actual vs. Predicted Power (Scatter Plot)')
    ax3.set_xlabel('Actual Power (MW)')
    ax3.set_ylabel('Predicted Power (MW)')
    visualizations.append(fig3)

    # Distribution ratios
    distribution_ratios = [0.20, 0.45, 0.35]

    def make_autopct(values):
        def my_autopct(pct):
            total = sum(values)
            val = int(round(pct*total/100.0)) if not np.isnan(total) else 0
            return '{p:.2f}%\n({v:d} MW)'.format(p=pct, v=val)
        return my_autopct

    # Pie chart for Predicted Power Distribution
    predicted_distribution = [predicted_power * ratio for ratio in distribution_ratios]
    fig4, ax4 = plt.subplots()
    ax4.pie(predicted_distribution, labels=['Node 1', 'Node 2', 'Node 3'], autopct=make_autopct(predicted_distribution))
    ax4.set_title('Predicted Power Distribution among Nodes')
    visualizations.append(fig4)

    # Pie chart for Actual Power Distribution
    actual_distribution = [actual_power * ratio for ratio in distribution_ratios]
    fig5, ax5 = plt.subplots()
    ax5.pie(actual_distribution, labels=['Node 1', 'Node 2', 'Node 3'], autopct=make_autopct(actual_distribution))
    ax5.set_title('Actual Power Distribution among Nodes')
    visualizations.append(fig5)

    return visualizations

# Load data
train_test_data, validation_data = load_data()
train_test_data = add_time_features(train_test_data)
validation_data = add_time_features(validation_data)

# Train the model
rf_model, features, target = train_model(train_test_data)

# Streamlit UI
st.title("Power Generated Prediction for 1st 3 months of 2024")
date = st.date_input("Choose Date")
time = st.time_input("Choose Time")
date_time_input = pd.to_datetime(f"{date} {time}")

if st.button("Predict"):
    predicted_power, actual_power, accuracy = predict_and_evaluate(rf_model, features, validation_data, date_time_input)
    
    if predicted_power is not None and actual_power is not None:
        st.write(f"Predicted Power: {predicted_power} MW")
        st.write(f"Actual Power: {actual_power} MW")
        st.write(f"Accuracy of Prediction: {accuracy:.2f}%")

        visualizations = create_visualizations(validation_data, date_time_input, predicted_power, actual_power, rf_model, features)
        for vis in visualizations:
            st.pyplot(vis)
    else:
        st.write("Data not available for the selected date and time, or an error occurred in prediction.")
